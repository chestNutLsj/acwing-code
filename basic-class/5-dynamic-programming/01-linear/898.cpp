// 数字三角形
#include <iostream>
using namespace std;

const int N = 510;
int       f[N][N]; // f[i][j] 表示从三角形顶部到达点(i,j)的最大路径和
/*
! [i]表示i轴坐标，(j)表示j轴坐标

              [1]  (1)
            [2]  7   (2)
          [3]  3   8   (3)
        [4]  8   1   0   (4)
      [5]  2   7   4   4   (5)
         4   5   2   6   5

 */

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            cin >> f[i][j];

    // 从三角形的倒数第二行开始向上逐行计算每个点的最大路径和
    for (int i = n - 1; i >= 1; i--) // 从下往上遍历行
        for (int j = 1; j <= i; j++) // 在当前行中从左到右遍历

            // 更新当前点的最大路径和为：从它下方和右下方选一个较大值，再加上当前点的值
            f[i][j] = max(f[i + 1][j + 1], f[i + 1][j]) + f[i][j];

    // 输出从顶点到底边的最大路径和，这个值在更新后存储在f[1][1]中
    cout << f[1][1] << endl;
}